

@displacement_top: 200px;
@displacement_left: 630px;
@diameter_inner: 790px;
@diameter_outer: 1460px;
@perspective_depth: 1000px;
@perspective_rotate: -15deg;


body {
    background-color: black;
}

/**
 * Top level container which defines the perspective depth.
 */
#perspective_parent {
    perspective: @perspective_depth;
    perspective-origin: 50% 50%;
    
    position: absolute;
    top: @displacement_top;
    left: @displacement_left;
    width: @diameter_outer;
    height: @diameter_outer;
}

/**
 * Child of the perspective container, contains the rest of the page elements.
 */
#body_container {
    transform: rotateX(@perspective_rotate);
    overflow: hidden;
    
    position: absolute;
    top: 0;
    left: 0;
    width: @diameter_outer;
    height: @diameter_outer;
}

/**
 * A cute little circled dot to mark the centrepoint.
 */
#crosshair {
    z-index: 100;
    height: 20px;
    width: 20px;
    position: absolute;
    top: (@diameter_outer/2) - 10px; /* + @displacement_top; */
    left: (@diameter_outer/2) - 10px; /* + @displacement_left; */
    
    background-image: radial-gradient(circle, white 1px, transparent 8px, white 10px, transparent 0);
    
    .disable_user_interaction;
}

/**
 * The container for the globe.
 * Height and width should be equal.
 * Z-index should be lower than other divs.
 */
#globe {
    z-index: 0;
    height: @diameter_outer;
    width: @diameter_outer;
    position: absolute;
    top: 0; /* @displacement_top; */
    left: 0; /* @displacement_left; */
}

/**
 * The mask to place over the globe.
 * Dimensions and position should match globe container.
 */
#globe_mask {
    z-index: 1;
    height: @diameter_outer;
    width: @diameter_outer;
    position: absolute;
    top: 0; /* @displacement_top; */
    left: 0; /* @displacement_left; */
    
    background-image: radial-gradient(circle, transparent (@diameter_inner/2), white 0, white (@diameter_outer/2), black 0);
    
    .disable_user_interaction;
}

/**
 * The mask that covers anything that would drift over the table edge.
 * Dimensions and position should match globe container.
 */
#table_mask {
    z-index: 100;
    height: @diameter_outer;
    width: @diameter_outer;
    position: absolute;
    top: 0; /* @displacement_top; */
    left: 0; /* @displacement_left; */
    
    background-image: radial-gradient(circle, transparent (@diameter_outer/2), black 0);
    
    .disable_user_interaction;
}

@keyframes clockwise {
    from {transform:rotate(0deg);}
    to {transform:rotate(360deg);}
}

@keyframes anticlockwise {
    from {transform:rotate(0deg);}
    to {transform:rotate(-360deg);}
}

.rotate(@clockwise: true, @duration)
        when (isnumber(@duration))
        and (@clockwise) {
    animation-name: clockwise;
    animation-duration: @duration;
    animation-iteration-count: infinite;
    animation-timing-function: linear;
}

.rotate(@clockwise: true, @duration)
        when (isnumber(@duration)) 
        and not (@clockwise) {
    animation-name: anticlockwise;
    animation-duration: @duration;
    animation-iteration-count: infinite;
    animation-timing-function: linear;
}

/**
 * With visually intensive elements, you may want to encourage GPU rendering.
 * This is done by tricking the browser into 3D rendering.
 */
.encourage_GPU_rendering() {
    transform: translateZ(0);
    /* transform: translate3d(0, 0, 0); */
    transform-style: preserve-3d;
    backface-visibility: hidden;
}

/**
 * Effectively allows the user to click underlying elements.
 * Might want to disable later, like when Kinect integration is finished.
 * You may want to disable this, rely on Pointer Lock, and use elementFromPoint
 * to simulate left clicks on the table with Kinect depth data.
 */
.disable_user_interaction() {
    user-select: none;
    pointer-events: none;
}
